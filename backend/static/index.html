<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historabook AI</title>
    <style>
        /* --- STYLES --- */
        body { font-family: 'Segoe UI', sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: #f0f2f5; color: #333; }
        .card { background: white; padding: 25px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 20px; }
        #narration-text { font-size: 1.3em; line-height: 1.6; padding: 15px; background: #f1f9ff; border-left: 5px solid #3498db; border-radius: 4px; }
        #visual-box { 
            width: 100%; height: 350px; background: #2d3436; color: #dfe6e9; display: flex; flex-direction: column; 
            align-items: center; justify-content: center; border-radius: 12px; position: relative; overflow: hidden;
            background-size: contain; 
            background-repeat: no-repeat;
            background-position: center;
        }
        button { cursor: pointer; font-size: 14px; padding: 8px 15px; border-radius: 6px; border: 1px solid #ccc; background: #fff; margin: 5px 2px; }
        .controls { display: flex; gap: 15px; align-items: center; margin-top: 20px; border-top: 2px solid #f1f1f1; padding-top: 20px; }
        #mic-btn { width: 70px; height: 70px; border-radius: 50%; background: #e74c3c; color: white; font-size: 30px; border: none; }
        #mic-btn.recording { animation: pulse 1.5s infinite; }
        .scene-btn { width: 100%; }

        /* Loading Overlay Style */
        #visual-loading-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7); color: white;
            display: none; align-items: center; justify-content: center;
            font-size: 1.5em; text-align: center;
            z-index: 10;
        }
    </style>
</head>
<body>

    <h1>üìö Historabook AI</h1>

    <div class="card" id="setup-panel">
        <h3>üìñ Library</h3>
        <div id="status-msg" style="color: #666; margin-bottom: 10px;">Connecting to server...</div>
        <div id="scene-list" style="max-height: 300px; overflow-y: auto;"></div>
    </div>

    <div class="card" id="stage" style="display:none;">
        <div id="visual-box">
            <div id="visual-loading-overlay">
                <span id="loading-message">‚è≥ Generating Visuals...</span>
            </div>
            <div id="visual-icon">üñºÔ∏è</div>
            <div id="visual-desc">Visual Description...</div>
        </div>

        <div id="narration-text">Loading lesson...</div>
        <audio id="audio-player" style="display:none;"></audio>

        <div style="margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 10px;">
            <label for="lang-select">Voice Language:</label>
            <select id="lang-select">
                <option value="en">English (Default)</option>
                <option value="hi">‡§π‡§ø‡§®‡•ç‡§¶‡•Ä (Hindi)</option>
                <option value="kn">‡≤ï‡≤®‡≥ç‡≤®‡≤° (Kannada)</option>
                <option value="sa">‡§∏‡§Ç‡§∏‡•ç‡§ï‡•É‡§§ (Sanskrit)</option>
            </select>
            <button onclick="requestReexplain()" style="background:#f1c40f; color:#333; border:none; margin-left: 10px;">Re-Explain</button>
            <button onclick="requestSocraticQuiz()" style="background:#2ecc71; color:white; border:none;">Quiz Me!</button>
        </div>

        <div class="controls">
            <!-- Back Button -->
            <button onclick="playPrevious()" style="background:#95a5a6; color:white;">‚¨Ö Back</button> 
            
            <button id="mic-btn" onmousedown="startRecording()" onmouseup="stopRecording()" ontouchstart="startRecording()" ontouchend="stopRecording()">
                üé§
            </button>
            <div class="status-bar" style="flex-grow: 1;">
                <span id="status-text">Hold Mic to speak...</span>
            </div>
            <button onclick="playNext()" style="background:#3498db; color:white; border:none;">Next Segment ‚û°</button>
        </div>
    </div>

    <script>
        // CORE CONFIG
        const API_BASE = window.location.origin;
        const API = API_BASE + "/api";
        
        let currentPlan = null;
        let currentSegmentIndex = 0;
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        
        let activeCatalogId = null;
        let animationInterval = null;
        
        let allSceneIds = []; 
        let currentSceneIndexInList = -1;

        // --- INITIALIZATION ---
        window.onload = async function() {
            const audio = document.getElementById('audio-player');
            audio.onended = () => {
                if (currentPlan) {
                    playNext(true); // Auto-advance to the next segment/scene
                }
            };
            loadScenes();
        };

        // --- LOAD LOGIC ---
        async function loadScenes() {
            const msg = document.getElementById('status-msg');
            msg.innerText = "üîç Finding latest book...";
            allSceneIds = []; 
            currentSceneIndexInList = -1;
            
            try {
                const catRes = await fetch(`${API}/catalog/`);
                if(!catRes.ok) throw new Error("Server not responding to Catalog API.");
                const books = await catRes.json();

                let foundScenes = false;
                
                for (let i = books.length - 1; i >= 0; i--) {
                    const book = books[i];
                    msg.innerText = `Checking book: "${book.title}"...`;

                    const sceneRes = await fetch(`${API}/plan/list/${book.id}`);
                    const scenes = await sceneRes.json();

                    if (scenes.length > 0) {
                        activeCatalogId = book.id;
                        msg.innerHTML = `‚úÖ Loaded <b>"${book.title}"</b> (${scenes.length} scenes)`;

                        scenes.forEach((s, index) => {
                            allSceneIds.push(s.id); 
                            const btn = document.createElement('button');
                            btn.className = 'scene-btn';
                            btn.innerHTML = `<b>${s.title}</b>`;
                            btn.onclick = () => startLesson(s.id, index); 
                            document.getElementById('scene-list').appendChild(btn);
                        });
                        foundScenes = true;
                        break;
                    }
                }

                if (!foundScenes) {
                    msg.innerHTML = "‚ö†Ô∏è No books found with Scenes. Please upload a PDF and wait for extraction.";
                }

            } catch (e) {
                msg.innerHTML = `‚ùå Connection Failed. Is the server running? (${e.message})`;
                console.error("Initialization Error:", e);
            }
        }

        async function startLesson(sceneId, indexInList) {
            currentSceneIndexInList = indexInList;
            
            document.getElementById('setup-panel').style.display = 'none';
            document.getElementById('stage').style.display = 'block';
            updateStatus("ü§ñ AI is writing lesson plan...");
            
            currentPlan = null; 

            const res = await fetch(`${API}/plan/${sceneId}`, { method: 'POST' });
            currentPlan = await res.json();
            currentSegmentIndex = 0;
            if(currentPlan.segments && currentPlan.segments.length > 0) {
                playSegment(currentPlan.segments[0]);
            }
        }
        
        // --- CORE PLAYBACK LOOP (Movie Mode & Animation) ---
        async function playSegment(seg) {
            // 1. Cleanup
            document.getElementById('audio-player').pause(); 
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            // 2. Prepare UI for loading (Shows text, holds old image until ready)
            document.getElementById('narration-text').innerText = seg.text;
            document.getElementById('visual-loading-overlay').style.display = 'flex'; // Show loading overlay
            document.getElementById('loading-message').innerText = "‚è≥ Generating Visuals...";
            document.getElementById('visual-icon').style.display = 'none'; 
            document.getElementById('visual-desc').style.display = 'none'; 
            
            updateStatus("üîä Speaking & Generating Visuals...");

            // Fetch requests run in parallel
            const audioPromise = fetch(`${API}/audio/speak`, {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ text: seg.text, lang: document.getElementById('lang-select').value })
            });
            const visualPromise = fetch(`${API}/visuals/generate`, {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ prompt: seg.visual.background })
            });

            // Wait for both to finish
            const [audioRes, visualRes] = await Promise.all([audioPromise, visualPromise]);
            
            // Audio Playback
            const audioData = await audioRes.json();
            const audio = document.getElementById('audio-player');
            audio.src = API_BASE + audioData.audio_url; 
            audio.play();

            // Visual Update & Animation (Only occurs AFTER files are received)
            const visualData = await visualRes.json();
            const visualBox = document.getElementById('visual-box');
            
            if (visualRes.ok && visualData.image_urls && visualData.image_urls.length > 0) {
                // Preload and start animation loop
                document.getElementById('visual-loading-overlay').style.display = 'none'; 
                document.getElementById('visual-desc').innerText = seg.visual.background; // Display new description
                document.getElementById('visual-desc').style.display = 'block';
                
                const imageList = visualData.image_urls;
                let currentFrameIndex = 0;
                const frameRateMs = 1500; 

                // Show first frame immediately
                visualBox.style.backgroundImage = `url(${API_BASE + imageList[0]})`;

                animationInterval = setInterval(() => {
                    currentFrameIndex = (currentFrameIndex + 1) % imageList.length;
                    visualBox.style.backgroundImage = `url(${API_BASE + imageList[currentFrameIndex]})`;
                }, frameRateMs);

            } else {
                // VRAM CRASH/Error Handler
                document.getElementById('visual-loading-overlay').style.display = 'none';
                document.getElementById('visual-icon').style.display = 'block';
                document.getElementById('visual-icon').innerText = "‚ö†Ô∏è";
                document.getElementById('visual-desc').innerText = visualData.detail || "Image generation failed (VRAM issue).";
                visualBox.style.backgroundImage = 'none';
                visualBox.style.background = '#e74c3c';
            }
        }

        // --- NAVIGATION LOGIC (Movie Mode Autoplay) ---
        function playNext(autoAdvance = false) {
            if(!currentPlan) return;
            
            if (!autoAdvance) {
                 // Manual click stops audio and animation instantly
                 document.getElementById('audio-player').pause();
                 if (animationInterval) clearInterval(animationInterval);
                 animationInterval = null;
            }
            
            // 1. Advance Segment
            currentSegmentIndex++;
            
            if(currentSegmentIndex < currentPlan.segments.length) {
                // A. Next segment in current scene
                playSegment(currentPlan.segments[currentSegmentIndex]);
            } else {
                // B. End of Current Scene - Check for Next Scene
                if (currentSceneIndexInList < allSceneIds.length - 1) {
                    const nextSceneId = allSceneIds[currentSceneIndexInList + 1];
                    updateStatus("‚úÖ Scene Complete. Auto-advancing to next scene...");
                    startLesson(nextSceneId, currentSceneIndexInList + 1); 
                } else {
                    // C. End of Book
                    updateStatus("üìö End of Book. All chapters reviewed.");
                }
            }
        }

        function playPrevious() {
            if (!currentPlan) return;

            // Stop current playback
            document.getElementById('audio-player').pause();
            if (animationInterval) clearInterval(animationInterval);
            animationInterval = null;

            // 1. Check if we can go back one segment
            if (currentSegmentIndex > 0) {
                currentSegmentIndex--;
                playSegment(currentPlan.segments[currentSegmentIndex]);
                
            // 2. Check if we need to go back to the previous scene
            } else if (currentSceneIndexInList > 0) {
                const prevSceneId = allSceneIds[currentSceneIndexInList - 1];
                const prevSceneIndex = currentSceneIndexInList - 1;
                updateStatus("‚¨Ö Rewinding to previous scene...");
                
                // Restarting the previous scene will set its segment index to 0
                startLesson(prevSceneId, prevSceneIndex); 
                
            } else {
                updateStatus("Already at the start of the book.");
            }
        }

        // --- INTERACTIVE PAUSE / MICROPHONE LOGIC ---
        function interruptPlayback() {
            document.getElementById('audio-player').pause();
            if (animationInterval) clearInterval(animationInterval);
            animationInterval = null;
            updateStatus("‚è∏Ô∏è Playback interrupted. Waiting for question...");
        }
        
        function requestReexplain() {
            const currentSegment = currentPlan.segments[currentSegmentIndex];
            document.getElementById('narration-text').innerText = "AI: I will re-explain that point now.";
            updateStatus("‚è≥ Re-explaining...");
            playSegment(currentSegment);
        }
        
        function requestSocraticQuiz() {
            const currentQuestion = currentPlan.segments[currentSegmentIndex].checkpoint_question;
            document.getElementById('narration-text').innerText = "AI: Here is your quiz question...";
            updateStatus("‚è≥ Generating Quiz...");
            alert("Quiz Time! The question is: " + (currentQuestion || "Please ask a question yourself!"));
        }

        async function startRecording() {
            if(isRecording) return;
            interruptPlayback(); // Pause the ongoing lesson!
            
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            isRecording = true;
            
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.start();
            
            document.getElementById('mic-btn').classList.add('recording');
            updateStatus("üëÇ Listening... (Release to send)");
        }

        async function stopRecording() {
            if(!isRecording || !mediaRecorder) return;
            mediaRecorder.stop();
            isRecording = false;
            document.getElementById('mic-btn').classList.remove('recording');
            updateStatus("‚è≥ Thinking...");
            
            // Clear animation during conversation
            if (animationInterval) {
                 clearInterval(animationInterval);
                 animationInterval = null;
            }
            
            mediaRecorder.onstop = async () => {
                const blob = new Blob(audioChunks, { type: 'audio/wav' });
                const formData = new FormData();
                formData.append("file", blob, "input.wav");
                
                try {
                    const transRes = await fetch(`${API}/listen/transcribe`, { method: 'POST', body: formData });
                    const transData = await transRes.json();
                    
                    document.getElementById('narration-text').innerHTML = `<span style="color:#888;">You:</span> "${transData.text}"`;
                    updateStatus("ü§ñ AI is formulating an answer...");
                    
                    const chatRes = await fetch(`${API}/chat/reply`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            question: transData.text,
                            catalog_id: activeCatalogId
                        })
                    });
                    const chatData = await chatRes.json();
                    
                    document.getElementById('narration-text').innerHTML += `<br><br><span style="color:#3498db;">AI:</span> "${chatData.text}"`;
                    
                    const audio = document.getElementById('audio-player');
                    audio.src = API_BASE + chatData.audio_url;
                    audio.play();
                    
                    // D. Resume lesson after response
                    audio.onended = () => {
                        updateStatus("‚úÖ Answer complete. Resuming lesson.");
                        playSegment(currentPlan.segments[currentSegmentIndex]); // Resume current segment
                    };

                } catch (e) {
                    console.error("Full Loop Error:", e);
                    updateStatus("‚ùå Error: See console for details.");
                }
            };
        }

        function updateStatus(msg) {
            document.getElementById('status-text').innerText = msg;
        }
        
        function getVisualIcon(action) {
            if(action && action.includes("zoom")) return "üîç";
            if(action && action.includes("pan")) return "‚ÜîÔ∏è";
            return "üñºÔ∏è";
        }
    </script>
</body>
</html>